//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftNIO open source project
//
// Copyright (c) 2017-2018 Apple Inc. and the SwiftNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

#if compiler(>=5.1)
@_implementationOnly import CNIOBoringSSL
#else
import CNIOBoringSSL
#endif
import Foundation
import NIOSSL

// TODO: Use PKCS#12 bundle instead.

// This function generates a random number suitable for use in an X509
// serial field. This needs to be a positive number less than 2^159
// (such that it will fit into 20 ASN.1 bytes).
// This also needs to be portable across operating systems, and the easiest
// way to do that is to use either getentropy() or read from urandom. Sadly
// we need to support old Linuxes which may not possess getentropy as a syscall
// (and definitely don't support it in glibc), so we need to read from urandom.
// In the future we should just use getentropy and be happy.
private func boringSSLGenerateSerialNumber() -> ASN1_INTEGER {
    let bytesToRead = 20
    let fd = open("/dev/urandom", O_RDONLY)
    precondition(fd != -1)
    defer {
        close(fd)
    }
    
    var readBytes = Array.init(repeating: UInt8(0), count: bytesToRead)
    let readCount = readBytes.withUnsafeMutableBytes {
        return read(fd, $0.baseAddress, bytesToRead)
    }
    precondition(readCount == bytesToRead)
    
    // Our 20-byte number needs to be converted into an integer. This is
    // too big for Swift's numbers, but BoringSSL can handle it fine.
    let bn = CNIOBoringSSL_BN_new()
    defer {
        CNIOBoringSSL_BN_free(bn)
    }
    
    _ = readBytes.withUnsafeBufferPointer {
        CNIOBoringSSL_BN_bin2bn($0.baseAddress, $0.count, bn)
    }
    
    // We want to bitshift this right by 1 bit to ensure it's smaller than
    // 2^159.
    CNIOBoringSSL_BN_rshift1(bn, bn)
    
    // Now we can turn this into our ASN1_INTEGER.
    var asn1int = ASN1_INTEGER()
    CNIOBoringSSL_BN_to_ASN1_INTEGER(bn, &asn1int)
    
    return asn1int
}

/// BoringSSL generate RSA private key.
/// - Returns: The RSA `EVP_PKEY`.
func boringSSLGenerateRSAPrivateKey() -> UnsafeMutablePointer<EVP_PKEY> {
    let exponent = CNIOBoringSSL_BN_new()
    defer {
        CNIOBoringSSL_BN_free(exponent)
    }
    
    CNIOBoringSSL_BN_set_u64(exponent, 0x10001)
    
    let rsa = CNIOBoringSSL_RSA_new()!
    let generateRC = CNIOBoringSSL_RSA_generate_key_ex(rsa, CInt(2048), exponent, nil)
    precondition(generateRC == 1)
    
    let pkey = CNIOBoringSSL_EVP_PKEY_new()!
    let assignRC = CNIOBoringSSL_EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa)
    
    precondition(assignRC == 1)
    return pkey
}

private func boringSSLX509AddExtension(x509: OpaquePointer, nid: CInt, value: String) {
    var extensionContext = X509V3_CTX()
    
    CNIOBoringSSL_X509V3_set_ctx(&extensionContext, x509, x509, nil, nil, 0)
    let ext = value.withCString { (pointer) in
        return CNIOBoringSSL_X509V3_EXT_nconf_nid(nil, &extensionContext, nid, UnsafeMutablePointer(mutating: pointer))
    }!
    CNIOBoringSSL_X509_add_ext(x509, ext, -1)
    CNIOBoringSSL_X509_EXTENSION_free(ext)
}

private func boringSSLX509NameAddEntry(name: OpaquePointer?, nid: CInt, value: String) {
    value.withCString { pointer in
        pointer.withMemoryRebound(to: UInt8.self, capacity: value.lengthOfBytes(using: .utf8)) { pointer -> Void in
            CNIOBoringSSL_X509_NAME_add_entry_by_NID(name, nid, MBSTRING_UTF8, pointer, CInt(value.lengthOfBytes(using: .utf8)), -1, 0)
        }
    }
}

/// BoringSSL issue self signed certificate with private key, certificate authority and hostname.
/// - Parameters:
///   - key: The private key for this self signed certificate, if nil a new key with generated by function `boringSSLGenerateRSAPrivateKey()`
///   - ca: The certificate authority and it's private key pairs.
///   - hostname: The hostname for this certificate.
/// - Returns: Self signed certificate `X509` and `EVP_PKEY` pairs.
func boringSSLIssueSelfSignedCertificate(key: UnsafeMutablePointer<EVP_PKEY>? = nil, ca: (OpaquePointer, UnsafeMutablePointer<EVP_PKEY>), hostname: String) -> (OpaquePointer, UnsafeMutablePointer<EVP_PKEY>) {
    let pubkey = key ?? boringSSLGenerateRSAPrivateKey()
    let req = CNIOBoringSSL_X509_REQ_new()
    
    /* Set the public key. */
    CNIOBoringSSL_X509_REQ_set_pubkey(req, pubkey)
    
    /* Set the DN of the request. */
    let name = CNIOBoringSSL_X509_NAME_new()
    
    boringSSLX509NameAddEntry(name: name, nid: NID_organizationName, value: "Netbot")

    let splits = hostname.split(separator: ".")
    let commonName = splits.count > 2 ? splits.suffix(2).joined(separator: ".") : splits.joined(separator: ".")
    boringSSLX509NameAddEntry(name: name, nid: NID_commonName, value: commonName)
    
    CNIOBoringSSL_X509_REQ_set_subject_name(req, name)
    
    /* Self-sign the request to prove that we posses the key. */
    CNIOBoringSSL_X509_REQ_sign(req, pubkey, CNIOBoringSSL_EVP_sha256())
    
    /* Sign with the CA. */
    let x = CNIOBoringSSL_X509_new()!
    CNIOBoringSSL_X509_set_version(x, 2)
    
    // NB: X509_set_serialNumber uses an internal copy of the ASN1_INTEGER, so this is
    // safe, there will be no use-after-free.
    var serial = boringSSLGenerateSerialNumber()
    CNIOBoringSSL_X509_set_serialNumber(x, &serial)
    
    let notBefore = CNIOBoringSSL_ASN1_TIME_new()!
    var now = time(nil)
    CNIOBoringSSL_ASN1_TIME_set(notBefore, now)
    CNIOBoringSSL_X509_set_notBefore(x, notBefore)
    CNIOBoringSSL_ASN1_TIME_free(notBefore)
    
    now += 86400 * 365  // Give ourselves 1 year.
    let notAfter = CNIOBoringSSL_ASN1_TIME_new()!
    CNIOBoringSSL_ASN1_TIME_set(notAfter, now)
    CNIOBoringSSL_X509_set_notAfter(x, notAfter)
    CNIOBoringSSL_ASN1_TIME_free(notAfter)
    
    CNIOBoringSSL_X509_set_subject_name(x, name)
    CNIOBoringSSL_X509_set_pubkey(x, pubkey)
    
    /* Set issuer name to CA's subject. */
    CNIOBoringSSL_X509_set_issuer_name(x, CNIOBoringSSL_X509_get_subject_name(ca.0))
    
    boringSSLX509AddExtension(x509: x, nid: NID_authority_key_identifier, value: "keyid,issuer")
    boringSSLX509AddExtension(x509: x, nid: NID_basic_constraints, value: "CA:FALSE")
    boringSSLX509AddExtension(x509: x, nid: NID_ext_key_usage, value: "serverAuth,OCSPSigning")
    boringSSLX509AddExtension(x509: x, nid: NID_key_usage, value: "critical,digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment")
    // Support top-level domain and all sub-domains with a wildcard character *.
    boringSSLX509AddExtension(x509: x, nid: NID_subject_alt_name, value: "DNS:\(commonName),DNS:*.\(commonName)")
    boringSSLX509AddExtension(x509: x, nid: NID_subject_key_identifier, value: "hash")
    
    CNIOBoringSSL_X509_sign(x, ca.1, CNIOBoringSSL_EVP_sha256()) 
    CNIOBoringSSL_X509_REQ_free(req)
    
    return (x, pubkey)
}

/// BoringSSL issue certificate authority certificate and it's private key.
/// - Returns: The CA certificate `X509` and `EVP_PKEY` pairs.
func boringSSLIssueCACertificate() -> (OpaquePointer, UnsafeMutablePointer<EVP_PKEY>) {
    let pkey = boringSSLGenerateRSAPrivateKey()
    let x = CNIOBoringSSL_X509_new()!
    CNIOBoringSSL_X509_set_version(x, 2)
    
    // NB: X509_set_serialNumber uses an internal copy of the ASN1_INTEGER, so this is
    // safe, there will be no use-after-free.
    var serial = boringSSLGenerateSerialNumber()
    CNIOBoringSSL_X509_set_serialNumber(x, &serial)
    
    let notBefore = CNIOBoringSSL_ASN1_TIME_new()!
    var now = time(nil)
    CNIOBoringSSL_ASN1_TIME_set(notBefore, now)
    CNIOBoringSSL_X509_set_notBefore(x, notBefore)
    CNIOBoringSSL_ASN1_TIME_free(notBefore)
    
    now += 86400 * 365 * 10 // Give ourselves 10 years
    let notAfter = CNIOBoringSSL_ASN1_TIME_new()!
    CNIOBoringSSL_ASN1_TIME_set(notAfter, now)
    CNIOBoringSSL_X509_set_notAfter(x, notAfter)
    CNIOBoringSSL_ASN1_TIME_free(notAfter)
    
    CNIOBoringSSL_X509_set_pubkey(x, pkey)
    
    let name = CNIOBoringSSL_X509_get_subject_name(x)
    
    boringSSLX509NameAddEntry(name: name, nid: NID_organizationName, value: "Netbot")
    boringSSLX509NameAddEntry(name: name, nid: NID_commonName, value: "Netbot Generated Root CA")
    
    CNIOBoringSSL_X509_set_issuer_name(x, name)
    
    boringSSLX509AddExtension(x509: x, nid: NID_authority_key_identifier, value: "keyid,issuer")
    boringSSLX509AddExtension(x509: x, nid: NID_basic_constraints, value: "critical,CA:TRUE")
    boringSSLX509AddExtension(x509: x, nid: NID_subject_key_identifier, value: "hash")
    
    CNIOBoringSSL_X509_sign(x, pkey, CNIOBoringSSL_EVP_sha256())
    
    return (x, pkey)
}

/// Convert DER bytes to `X509 OpaquePointer`.
/// - Throws: May throw `NIOSSLError.failedToLoadCertificate` if failed to load certificate with given der bytes.
/// - Returns: The `X509 OpaquePointer`.
func boringSSLDERBytesToX509<Bytes: ContiguousBytes>(bytes: Bytes) throws -> OpaquePointer {
    try bytes.withUnsafeBytes { (ptr) -> OpaquePointer in
        let bio = CNIOBoringSSL_BIO_new_mem_buf(ptr.baseAddress, CInt(ptr.count))!
        
        defer {
            CNIOBoringSSL_BIO_free(bio)
        }
        
        guard let ref = CNIOBoringSSL_d2i_X509_bio(bio, nil) else {
            throw NIOSSLError.failedToLoadCertificate
        }
        
        return ref
    }
}

/// Convert DER bytes to `EVP_PKEY` pointer.
/// - Throws: May throw `NIOSSLError.failedToLoadPrivateKey` if failed to load private key with given der bytes.
/// - Returns: The `UnsafeMutablePointer<EVP_PKEY>`.
func boringSSLDERBytesToRSAKey<Bytes: ContiguousBytes>(bytes: Bytes) throws -> UnsafeMutablePointer<EVP_PKEY> {
    try bytes.withUnsafeBytes { ptr -> UnsafeMutablePointer<EVP_PKEY> in
        let bio = CNIOBoringSSL_BIO_new_mem_buf(ptr.baseAddress, CInt(ptr.count))!

        defer {
            CNIOBoringSSL_BIO_free(bio)
        }
        
        guard let ref = CNIOBoringSSL_d2i_PrivateKey_bio(bio, nil) else {
            throw NIOSSLError.failedToLoadPrivateKey
        }
        
        return ref
    }
}

extension OpaquePointer/*X509*/ {
    
    /// Extracts the bytes of this certificate in DER format.
    ///
    /// - returns: The DER-encoded bytes for this certificate.
    /// - throws: If an error occurred while serializing the certificate.
    func toDERBytes() throws -> [UInt8] {
        guard let bio = CNIOBoringSSL_BIO_new(CNIOBoringSSL_BIO_s_mem()) else {
            fatalError("Failed to malloc for a BIO handler")
        }
        
        defer {
            CNIOBoringSSL_BIO_free(bio)
        }
        
        let rc = CNIOBoringSSL_i2d_X509_bio(bio, self)
        guard rc == 1 else {
            throw BoringSSLError.unknownError([])
        }
        
        var dataPtr: UnsafeMutablePointer<CChar>? = nil
        let length = CNIOBoringSSL_BIO_get_mem_data(bio, &dataPtr)
        
        guard let bytes = dataPtr.map({ UnsafeRawBufferPointer(start: $0, count: length) }) else {
            fatalError("Failed to map bytes from a certificate")
        }
        
        return Array(bytes)
    }
}

extension UnsafeMutablePointer where Pointee == EVP_PKEY {
    
    /// Extracts the bytes of this certificate in DER format.
    ///
    /// - returns: The DER-encoded bytes for this `EVP_PKEY`.
    /// - throws: If an error occurred while serializing the `EVP_PKEY`.
    func toDERBytes() throws -> [UInt8] {
        guard let bio = CNIOBoringSSL_BIO_new(CNIOBoringSSL_BIO_s_mem()) else {
            fatalError("Failed to malloc for a BIO handler")
        }
        
        defer {
            CNIOBoringSSL_BIO_free(bio)
        }
        
        let rc = CNIOBoringSSL_i2d_PrivateKey_bio(bio, self)
        guard rc == 1 else {
            throw BoringSSLError.unknownError([])
        }
        
        var dataPtr: UnsafeMutablePointer<CChar>? = nil
        let length = CNIOBoringSSL_BIO_get_mem_data(bio, &dataPtr)
        
        guard let bytes = dataPtr.map({ UnsafeRawBufferPointer(start: $0, count: length) }) else {
            fatalError("Failed to map bytes from a private key")
        }
        
        return Array(bytes)
    }
}

func boringSSLIssueSelfSignedCertificate(hostname: String) throws -> (NIOSSLCertificate, NIOSSLPrivateKey) {
    
    let fileURLForCA: URL
    let fileURLForCAPrivateKey: URL
    let fileURLForPrivateKey: URL
    let fileURLForSelfSignedCertificate: URL
    
    let autoGen = true
    if autoGen {
        fileURLForCA = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/test/boringssl.ca.der")
        fileURLForCAPrivateKey = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/test/boringssl.ca.privateKey.der")
        fileURLForPrivateKey = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/test/boringssl.privateKey.der")
        fileURLForSelfSignedCertificate = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/test/boringssl.\(hostname).der")
    } else {
        fileURLForCA = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/boringssl.ca.der")
        fileURLForCAPrivateKey = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/boringssl.ca.privateKey.der")
        fileURLForPrivateKey = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/test.privateKey.der")
        fileURLForSelfSignedCertificate = URL(fileURLWithPath: "/Users/Paul/Developer/certificate/boringssl.\(hostname).der")
    }
    
    let boringSSLIssuedCACertificate: (OpaquePointer, UnsafeMutablePointer<EVP_PKEY>)
    if FileManager.default.fileExists(atPath: fileURLForCA.path) {
        boringSSLIssuedCACertificate = (
            try boringSSLDERBytesToX509(bytes: Data(contentsOf: fileURLForCA)),
            try boringSSLDERBytesToRSAKey(bytes: Data(contentsOf: fileURLForCAPrivateKey))
        )
    } else {
        boringSSLIssuedCACertificate = boringSSLIssueCACertificate()
    }
    
    let key: UnsafeMutablePointer<EVP_PKEY>
    if FileManager.default.fileExists(atPath: fileURLForPrivateKey.path) {
        key = try boringSSLDERBytesToRSAKey(bytes: Data(contentsOf: fileURLForPrivateKey))
    } else {
        key = boringSSLGenerateRSAPrivateKey()
    }
    
    let boringSSLIssuedSelfSignedCertificate: ([UInt8], [UInt8])
    if FileManager.default.fileExists(atPath: fileURLForSelfSignedCertificate.path) {
        boringSSLIssuedSelfSignedCertificate = (
            Array(try Data(contentsOf: fileURLForSelfSignedCertificate)),
            try key.toDERBytes()
        )
    } else {
        let certKeyPairs = boringSSLIssueSelfSignedCertificate(key: key, ca: boringSSLIssuedCACertificate, hostname: hostname)
        boringSSLIssuedSelfSignedCertificate = (try certKeyPairs.0.toDERBytes(), try certKeyPairs.1.toDERBytes())
    }
    
    DispatchQueue.global().async {
        try? Data(boringSSLIssuedCACertificate.0.toDERBytes()).write(to: fileURLForCA)
        try? Data(boringSSLIssuedCACertificate.1.toDERBytes()).write(to: fileURLForCAPrivateKey)
        try? Data(boringSSLIssuedSelfSignedCertificate.0).write(to: fileURLForSelfSignedCertificate)
        try? Data(boringSSLIssuedSelfSignedCertificate.1).write(to: fileURLForPrivateKey)
    }
    
    return (
        try NIOSSLCertificate(bytes: boringSSLIssuedSelfSignedCertificate.0, format: .der),
        try NIOSSLPrivateKey(bytes: boringSSLIssuedSelfSignedCertificate.1, format: .der)
    )
}
