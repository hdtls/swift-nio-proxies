//===----------------------------------------------------------------------===//
//
// This source file is part of the Netbot open source project
//
// Copyright (c) 2021 Junfeng Zhang and the Netbot project authors
// Licensed under Apache License v2.0
//
// See LICENSE for license information
// See CONTRIBUTORS.txt for the list of Netbot project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import XCTest

@testable import NEApp

///
/// NOTE: This file was generated by gyb
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
%{
  class Rule:
    def __init__(self, tag, className, expression="example.com", policy="DIRECT", externalResources=None):
      self.tag = tag
      self.className = className
      self.expression = expression
      self.policy = policy
      self.externalResources = externalResources

  pythonRules = [
    Rule("DOMAIN-KEYWORD", "DomainKeywordRule"),
    Rule("DOMAIN", "DomainRule"),
    Rule("DOMAIN-SET", "DomainSetRule", "http://domainset.com", externalResources=[
      "example1.com",
      ".example2.com"
    ]),
    Rule("DOMAIN-SUFFIX", "DomainSuffixRule"),
    Rule("FINAL", "FinalRule"),
    Rule("GEOIP", "GeoIPRule"),
    Rule("RULE-SET", "Ruleset", "http://ruleset.com", externalResources=[
      "DOMAIN,www.example.com",
      "DOMAIN-SUFFIX,example.com",
      "DOMAIN-KEYWORD,example"
    ]),
  ]
}%

final class ParsableRuleRepresentationTests: XCTestCase {
  %for rule in pythonRules:

  func testParsing${rule.className}() throws {
    %if rule.tag == "FINAL":
    let description = "${rule.tag},DIRECT"
    %else:
    let description = "${rule.tag},${rule.expression},DIRECT"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertFalse(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsing${rule.className}ThatContainComments() throws {
    %if rule.tag == "FINAL":
    let description = "${rule.tag},DIRECT // comments"
    %else:
    let description = "${rule.tag},${rule.expression},DIRECT // comments"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertFalse(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.comment, "comments")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsingDisabled${rule.className}() throws {
    %if rule.tag == "FINAL":
    let description = "# ${rule.tag},DIRECT"
    %else:
    let description = "# ${rule.tag},${rule.expression},DIRECT"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertTrue(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsing${rule.className}WithIncompleteDescriptionString() {
    %if rule.tag == "FINAL":
    let description = "${rule.tag}"
    XCTAssertNil(${rule.className}(description))
    %else:
    var description = "${rule.tag}"
    XCTAssertNil(${rule.className}(description))
    description = "${rule.tag},${rule.policy}"
    XCTAssertNil(${rule.className}(description))
    %end
  }

  func testParsing${rule.className}WithTypeMissmatchDescriptionString() {
    %if rule.tag == "FINAL":
    var description = "invalidSchema,DIRECT"
    %else:
    var description = "invalidSchema,${rule.expression},DIRECT"
    %end
    XCTAssertNil(${rule.className}(description))
    %for other in filter(lambda e: e != rule, pythonRules):
    %if rule.tag == "FINAL":
    description = "${rule.tag},DIRECT"
    %else:
    description = "${rule.tag},${rule.expression},DIRECT"
    %end
    XCTAssertNil(${other.className}(description))
    %end
  }
  %end

  func testDomainKeywordRuleMatchEvaluating() {
    let rule = DomainKeywordRule("DOMAIN-KEYWORD,example,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", true),
      ("example", true),
      ("pexample.com", true),
      ("example1.com", true),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testDomainRuleMatchEvaluating() {
    let rule = DomainRule("DOMAIN,example.com,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", false),
      ("example", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testDomainSuffixRuleMatchEvaluating() {
    let rule = DomainSuffixRule("DOMAIN-SUFFIX,example.com,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", true),
      ("example", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }
}
