//===----------------------------------------------------------------------===//
//
// This source file is part of the Netbot open source project
//
// Copyright (c) 2021 Junfeng Zhang and the Netbot project authors
// Licensed under Apache License v2.0
//
// See LICENSE for license information
// See CONTRIBUTORS.txt for the list of Netbot project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import NIOCore
import XCTest

@testable import NEApp

///
/// NOTE: This file was generated by gyb
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
%{
  class Rule:
    def __init__(self, tag, className, expression="example.com", policy="DIRECT"):
      self.tag = tag
      self.className = className
      self.expression = expression
      self.policy = policy

  pythonRules = [
    Rule("DOMAIN-KEYWORD", "DomainKeywordRule", "example"),
    Rule("DOMAIN", "DomainRule"),
    Rule("DOMAIN-SET", "DomainSetRule", "http://domainset.com"),
    Rule("DOMAIN-SUFFIX", "DomainSuffixRule"),
    Rule("FINAL", "FinalRule", ""),
    Rule("GEOIP", "GeoIPRule", "CN"),
    Rule("IP-CIDR", "IPCIDRRule", "192.168.0.1/20"),
    Rule("RULE-SET", "Ruleset", "http://ruleset.com"),
  ]
}%

final class ParsableRuleRepresentationTests: XCTestCase {
  %for rule in pythonRules:

  func testParsing${rule.className}() throws {
    %if rule.tag == "FINAL":
    let description = "${rule.tag},DIRECT"
    %else:
    let description = "${rule.tag},${rule.expression},DIRECT"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertFalse(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsing${rule.className}ThatContainComments() throws {
    %if rule.tag == "FINAL":
    let description = "${rule.tag},DIRECT // comments"
    %else:
    let description = "${rule.tag},${rule.expression},DIRECT // comments"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertFalse(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.comment, "comments")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsingDisabled${rule.className}() throws {
    %if rule.tag == "FINAL":
    let description = "# ${rule.tag},DIRECT"
    %else:
    let description = "# ${rule.tag},${rule.expression},DIRECT"
    %end
    let standardRule = try XCTUnwrap(${rule.className}(description))
    XCTAssertTrue(standardRule.disabled)
    %if rule.tag == "FINAL":
    XCTAssertEqual(standardRule.expression, "")
    %else:
    XCTAssertEqual(standardRule.expression, "${rule.expression}")
    %end
    XCTAssertEqual(standardRule.policy, "${rule.policy}")
    XCTAssertEqual(standardRule.description, description)
  }

  func testParsing${rule.className}WithIncompleteDescriptionString() {
    %if rule.tag == "FINAL":
    let description = "${rule.tag}"
    XCTAssertNil(${rule.className}(description))
    %else:
    var description = "${rule.tag}"
    XCTAssertNil(${rule.className}(description))
    description = "${rule.tag},${rule.policy}"
    XCTAssertNil(${rule.className}(description))
    %end
  }

  func testParsing${rule.className}WithTypeMissmatchDescriptionString() {
    %if rule.tag == "FINAL":
    XCTAssertNil(${rule.className}("invalidSchema,DIRECT"))
    %else:
    XCTAssertNil(${rule.className}("invalidSchema,${rule.expression},DIRECT"))
    %end
    %for other in filter(lambda e: e != rule, pythonRules):
    %if rule.tag == "FINAL":
    XCTAssertNil(${rule.className}("${other.tag},DIRECT"))
    %else:
    XCTAssertNil(${rule.className}("${other.tag},${other.expression},DIRECT"))
    %end
    %end
  }
  %end

  func testDomainKeywordRuleMatchEvaluating() {
    let rule = DomainKeywordRule("DOMAIN-KEYWORD,example,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", true),
      ("example", true),
      ("pexample.com", true),
      ("example1.com", true),
      ("ex.ample.com", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testDomainRuleMatchEvaluating() {
    let rule = DomainRule("DOMAIN,example.com,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", false),
      ("example", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testDomainSuffixRuleMatchEvaluating() {
    let rule = DomainSuffixRule("DOMAIN-SUFFIX,example.com,DIRECT")!
    let testVectors = [
      ("example.com", true),
      ("www.example.com", true),
      ("example", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testDomainSetRuleMatchEvaluating() {
    var rule = DomainSetRule("DOMAIN-SET,http://domainset.com,DIRECT")!
    let url = Bundle.module.url(forResource: "domainset_test", withExtension: nil)!
    rule.loadAllRules(from: url)
    let testVectors = [
      ("example.com", true),
      ("example2.com", true),
      ("www.example2.com", true),
      ("www.example.com", false),
      ("example", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testFinalRuleMatchEvaluating() {
    let rule = FinalRule("FINAL,DIRECT")!
    // Final rule match anything.
    XCTAssertTrue(rule.match("any"))
  }

  func testGEOIPRuleMatchEvaluating() {

  }

  func testCreateIPCIDRRuleWithInvalidIPCIDRString() {
    let testVectors = [
      "192.168/21",
      "192.168.0.1",
      "192.168.0.1/33",
      "192.168.0.1/",
      "192.168.0.1/x",
      "/var/tmp/20",
      "var/20",
      "2001:4860:4860::8888",
      "2001:4860:4860::8888/129",
      "2001:4860:4860::8888/",
      "2001:4860:4860::8888/x",
    ]

    testVectors.forEach {
      XCTAssertNil(IPCIDRRule("IP-CIDR,\($0),DIRECT"))
    }
  }

  func testIPCIDRRuleMatchEvaluating() {
    var rule = IPCIDRRule("IP-CIDR,192.168.0.1/20,DIRECT")!
    var testVectors = [
      ("192.168.0.9", true),
      ("192.168.16.1", false),
      ("2001:4860:4860::8888", false),
      ("2001:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }

    rule = IPCIDRRule("IP-CIDR,2001:4860:4860::8888/32,DIRECT")!
    testVectors = [
      ("192.168.0.9", false),
      ("192.168.16.1", false),
      ("2001:4860:4860::8888", true),
      ("2001:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF", false),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testRulesetMatchEvaluating() {
    var rule = Ruleset("RULE-SET,http://ruleset.com,DIRECT")!
    let url = Bundle.module.url(forResource: "ruleset_test", withExtension: nil)!
    rule.loadAllRules(from: url)
    let testVectors = [
      ("example.com", false),
      ("line.me", true),
      ("www.example2.com", false),
      ("nowtv100.com", true),
      ("103.2.28.1", true),
    ]
    testVectors.forEach { pattern, expected in
      XCTAssertEqual(rule.match(pattern), expected)
    }
  }

  func testCreateAddressesWithIPCIDRString() throws {
    let testVectors = [
      ("192.168.0.1/20", ("192.168.0.0", "192.168.15.255")),
      ("192.168.0.1/0", ("0.0.0.0", "255.255.255.255")),
      ("192.168.0.1/32", ("192.168.0.1", "192.168.0.1")),
      (
        "2001:4860:4860::8888/32",
        ("2001:4860:0000:0000:0000:0000:0000:0000", "2001:4860:ffff:ffff:ffff:ffff:ffff:ffff")
      ),
      (
        "2001:4860:4860::8888/0",
        ("0000:0000:0000:0000:0000:0000:0000:0000", "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF")
      ),
      (
        "2001:4860:4860::8888/128",
        ("2001:4860:4860::8888", "2001:4860:4860::8888")
      ),
    ]

    try testVectors.forEach {
      let addresses = try IPCIDRRule.Addresses(cidr: $0.0)
      var expected = try SocketAddress(ipAddress: $0.1.0, port: 0)
      XCTAssertEqual(addresses.lowerBound, expected)

      expected = try SocketAddress(ipAddress: $0.1.1, port: 0)
      XCTAssertEqual(addresses.upperBound, expected)
    }
  }

  func testCreateAddressesWithInvalidIPCIDRString() throws {
    let testVectors = [
      "192.168/21",
      "192.168.0.1",
      "192.168.0.1/33",
      "192.168.0.1/",
      "192.168.0.1/x",
      "/var/tmp/20",
      "var/20",
      "2001:4860:4860::8888",
      "2001:4860:4860::8888/129",
      "2001:4860:4860::8888/",
      "2001:4860:4860::8888/x",
    ]

    try testVectors.forEach {
      XCTAssertThrowsError(try IPCIDRRule.Addresses(cidr: $0))
    }
  }

  func testCreateAddressesWithSocketAddressAndPrefix() throws {
    let testVectors = [
      (("192.168.0.1", 20), ("192.168.0.0", "192.168.15.255")),
      (("192.168.0.1", 0), ("0.0.0.0", "255.255.255.255")),
      (("192.168.0.1", 32), ("192.168.0.1", "192.168.0.1")),
      (
        ("2001:4860:4860::8888", 32),
        ("2001:4860:0000:0000:0000:0000:0000:0000", "2001:4860:ffff:ffff:ffff:ffff:ffff:ffff")
      ),
      (
        ("2001:4860:4860::8888", 0),
        ("0000:0000:0000:0000:0000:0000:0000:0000", "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF")
      ),
      (
        ("2001:4860:4860::8888", 128),
        ("2001:4860:4860::8888", "2001:4860:4860::8888")
      ),
    ]

    try testVectors.forEach {
      let addresses = try IPCIDRRule.Addresses(
        address: SocketAddress(ipAddress: $0.0.0, port: 0),
        maskBits: $0.0.1
      )
      var expected = try SocketAddress(ipAddress: $0.1.0, port: 0)
      XCTAssertEqual(addresses.lowerBound, expected)

      expected = try SocketAddress(ipAddress: $0.1.1, port: 0)
      XCTAssertEqual(addresses.upperBound, expected)
    }
  }

  func testCreateAddressesWithUnixDomainSocket() throws {
    let address = try SocketAddress(unixDomainSocketPath: "/var/tmp")
    XCTAssertThrowsError(try IPCIDRRule.Addresses(address: address, maskBits: 12))
  }

  func testIPv4AddressesContainsIPv4Address() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "127.0.0.1", port: 0),
      upperBound: try SocketAddress(ipAddress: "127.0.1.0", port: 0)
    )
    var address = try SocketAddress(ipAddress: "127.0.0.0", port: 0)
    XCTAssertFalse(addresses.contains(address))

    address = try SocketAddress(ipAddress: "127.0.0.1", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "127.0.0.2", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "127.0.1.0", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "127.0.1.1", port: 0)
    XCTAssertFalse(addresses.contains(address))
  }

  func testIPv4AddressesContainsUnixDomainSocket() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "127.0.0.1", port: 0),
      upperBound: try SocketAddress(ipAddress: "127.0.1.0", port: 0)
    )
    let address = try SocketAddress(unixDomainSocketPath: "/var/tmp")
    XCTAssertFalse(addresses.contains(address))
  }

  func testIPv6AddressesContainsIPv6Address() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "::7f00:0001", port: 0),
      upperBound: try SocketAddress(ipAddress: "::7f00:0100", port: 0)
    )
    var address = try SocketAddress(ipAddress: "::7f00:0000", port: 0)
    XCTAssertFalse(addresses.contains(address))

    address = try SocketAddress(ipAddress: "::7f00:0001", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "::7f00:0002", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "::7f00:0100", port: 0)
    XCTAssertTrue(addresses.contains(address))

    address = try SocketAddress(ipAddress: "::7f00:0101", port: 0)
    XCTAssertFalse(addresses.contains(address))
  }

  func testIPv6AddressesContainsUnixDomainSocket() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "::7f00:0001", port: 0),
      upperBound: try SocketAddress(ipAddress: "::7f00:0100", port: 0)
    )
    let address = try SocketAddress(unixDomainSocketPath: "/var/tmp")
    XCTAssertFalse(addresses.contains(address))
  }

  func testIPv4AddressesContainsIPv6Address() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "127.0.0.1", port: 0),
      upperBound: try SocketAddress(ipAddress: "127.0.1.0", port: 0)
    )
    let address = try SocketAddress(ipAddress: "::7f00:0000", port: 0)
    XCTAssertFalse(addresses.contains(address))
  }

  func testIPv6AddressesContainsIPv4Address() throws {
    let addresses = IPCIDRRule.Addresses(
      lowerBound: try SocketAddress(ipAddress: "::7f00:0001", port: 0),
      upperBound: try SocketAddress(ipAddress: "::7f00:0100", port: 0)
    )
    let address = try SocketAddress(ipAddress: "127.0.0.1", port: 0)
    XCTAssertFalse(addresses.contains(address))
  }
}
