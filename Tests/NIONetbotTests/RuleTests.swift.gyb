//===----------------------------------------------------------------------===//
//
// This source file is part of the Netbot open source project
//
// Copyright (c) 2021 Junfeng Zhang and the Netbot project authors
// Licensed under Apache License v2.0
//
// See LICENSE for license information
// See CONTRIBUTORS.txt for the list of Netbot project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import XCTest
@testable import NIONetbot
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif
%{
    class Rule:
        def __init__(self, tag, className, type, expression="swift.org", standardRules=None):
            self.tag = tag
            self.className = className
            self.type = type
            self.expression = expression
            self.standardRules = standardRules
    
    pythonRules = [
        Rule("DOMAIN", "DomainRule", ".domain"),
        Rule("DOMAIN-SUFFIX", "DomainSuffixRule", ".domainSuffix"),
        Rule("DOMAIN-KEYWORD", "DomainKeywordRule", ".domainKeyword"),
        Rule("DOMAIN-SET", "DomainSet", ".domainSet", "http://domainset.com", [
            "swift.org",
            ".apple.com"
        ]),
        Rule("GEOIP", "GeoIPRule", ".geoIp"),
        Rule("FINAL", "FinalRule", ".final"),
        Rule("RULE-SET", "RuleSet", ".ruleSet", "http://ruleset.com", [
            "DOMAIN,apple.com",
            "DOMAIN-SUFFIX,apple.com",
            "DOMAIN-KEYWORD,apple"
        ])
    ]
}%

private class MockURLProtocol: URLProtocol {

    static var stubs: [URL : Data] = [:]
    static func stub(url: URL, response: Data) {
        stubs[url] = response
    }

    override class func canInit(with request: URLRequest) -> Bool {
        guard let url = request.url else {
            return false
        }
        return stubs[url] != nil
    }

    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }

    override func startLoading() {
        guard let url = request.url else {
            return
        }

        let data: Data? = Self.stubs[url]

        client?.urlProtocol(
            self,
            didReceive: .init(
                url: url,
                mimeType: "text/plain",
                expectedContentLength: data?.count ?? -1,
                textEncodingName: "utf-8"
            ),
            cacheStoragePolicy: .notAllowed
        )

        if let data = data {
            client?.urlProtocol(self, didLoad: data)
        }
        client?.urlProtocolDidFinishLoading(self)
    }

    override func stopLoading() {}
}

final class RuleTests: XCTestCase {

    override class func setUp() {
        _ = URLProtocol.registerClass(MockURLProtocol.self)
        URLSession.shared.configuration.protocolClasses?.insert(MockURLProtocol.self, at: 0)
    }
    %for rule in pythonRules:

    func testParsing${rule.className}() throws {
        %if rule.tag == "FINAL":
        let string = "${rule.tag},DIRECT"
        %else:
        let string = "${rule.tag},${rule.expression},DIRECT"
        %end
        let standardRule = try AnyRule.init(string: string)
        XCTAssertEqual(standardRule.type, ${rule.type})
        %if rule.tag == "FINAL":
        XCTAssertEqual(standardRule.expression, "")
        %else:
        XCTAssertEqual(standardRule.expression, "${rule.expression}")
        %end
        XCTAssertEqual(standardRule.policy, "DIRECT")
        XCTAssertEqual(standardRule.comment, "")
    }

    func testParsing${rule.className}WithComment() throws {
        %if rule.tag == "FINAL":
        let string = "${rule.tag},DIRECT // this is rule comment."
        %else:
        let string = "${rule.tag},${rule.expression},DIRECT // this is rule comment."
        %end
        let standardRule = try AnyRule.init(string: string)
        XCTAssertEqual(standardRule.type, ${rule.type})
        %if rule.tag == "FINAL":
        XCTAssertEqual(standardRule.expression, "")
        %else:
        XCTAssertEqual(standardRule.expression, "${rule.expression}")
        %end
        XCTAssertEqual(standardRule.policy, "DIRECT")
        XCTAssertEqual(standardRule.comment, "this is rule comment.")
    }

    func testAppropriateErrorWhenParsing${rule.className}WithInvalidSchema() {
        %if rule.tag == "FINAL":
        let string = "invalidSchema,DIRECT // this is rule comment."
        %else:
        let string = "invalidSchema,${rule.expression},DIRECT // this is rule comment."
        %end

        XCTAssertThrowsError(try AnyRule.init(string: string)) { error in
            XCTAssertTrue(error is ProfileSerializationError)
            let actualErrorString = String(describing: error as! ProfileSerializationError)
            let expectedErrorString = String(
                describing: ProfileSerializationError.failedToParseRule(reason: .unsupported)
            )
            XCTAssertEqual(actualErrorString, expectedErrorString)
        }
    }

    func testAppropriateErrorWhenParsing${rule.className}WithMissingFieldRuleString() {
        %if rule.tag == "FINAL":
        XCTAssertThrowsError(try AnyRule.init(string: "${rule.tag}")) { error in
        %else:
        XCTAssertThrowsError(try AnyRule.init(string: "${rule.tag},${rule.expression}")) { error in
        %end
            XCTAssertTrue(error is ProfileSerializationError)
            let actualErrorString = String(describing: error as! ProfileSerializationError)
            let expectedErrorString = String(
                describing: ProfileSerializationError.failedToParseRule(reason: .missingField)
            )
            XCTAssertEqual(actualErrorString, expectedErrorString)
        }
    }
    %if not rule.tag.endswith("-SET"):

    func test${rule.className}Coding() throws {
        %if rule.tag == "FINAL":
        let jsonString = "${rule.tag},DIRECT // this is rule comment."
        %else:
        let jsonString = "${rule.tag},${rule.expression},DIRECT // this is rule comment."
        %end
        var data: Data!
        XCTAssertNoThrow(
            data = try JSONSerialization.data(
                withJSONObject: jsonString,
                options: .fragmentsAllowed
            )
        )
        XCTAssertNotNil(data)

        var standardRule: AnyRule!
        XCTAssertNoThrow(standardRule = try JSONDecoder().decode(AnyRule.self, from: data))
        XCTAssertNotNil(standardRule)
        XCTAssertEqual(standardRule.type, ${rule.type})
        %if rule.tag == "FINAL":
        XCTAssertEqual(standardRule.expression, "")
        %else:
        XCTAssertEqual(standardRule.expression, "${rule.expression}")
        %end
        XCTAssertEqual(standardRule.policy, "DIRECT")
        XCTAssertEqual(standardRule.comment, "this is rule comment.")

        var string: String!
        XCTAssertNoThrow(
            string =
                try JSONSerialization.jsonObject(
                    with: JSONEncoder().encode(standardRule),
                    options: .fragmentsAllowed
                ) as? String
        )
        XCTAssertNotNil(string)
        XCTAssertEqual(string, jsonString)
    }
    %else:

    #if os(iOS) || os(macOS) || os(tvOS) || os(watchOS)
    func test${rule.className}Coding() throws {
        let text = """
            %for l in rule.standardRules:
            ${l}
            %end
            """

        let expectation = self.expectation(description: "${rule.tag}")
        MockURLProtocol.stub(
            url: .init(string: "${rule.expression}")!,
            response: text.data(using: .utf8)!
        )
        let string = "${rule.tag},${rule.expression},DIRECT"
        let ${rule.className.lower()} = try AnyRule(string: string)
        ${rule.className.lower()}.performExternalResourcesLoading { _ in
            expectation.fulfill()
        }
        waitForExpectations(timeout: 15, handler: nil)

        XCTAssertEqual(${rule.className.lower()}.expression, "${rule.expression}")
        XCTAssertEqual(${rule.className.lower()}.policy, "DIRECT")
        XCTAssertEqual(${rule.className.lower()}.comment, "")
        XCTAssertEqual(
            try JSONSerialization.jsonObject(
                with: try JSONEncoder().encode(${rule.className.lower()}),
                options: .fragmentsAllowed
            ) as? String,
            string
        )
    }
    #endif
    %end
    %end
}
