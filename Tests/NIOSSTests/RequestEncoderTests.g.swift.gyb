//===----------------------------------------------------------------------===//
//
// This source file is part of the Netbot open source project
//
// Copyright (c) 2022 Junfeng Zhang and the Netbot project authors
// Licensed under Apache License v2.0
//
// See LICENSE for license information
// See CONTRIBUTORS.txt for the list of Netbot project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Crypto
import NIO
import NIONetbotMisc
import XCTest

@testable import NIOSS
%{
ciphers = [
    {
        "algo": "AES-128-GCM",
        "cipher": "AES.GCM",
        "key_size": 16,
        "salt_size": 16,
    },
    {
        "algo": "AES-256-GCM",
        "cipher": "AES.GCM",
        "key_size": 32,
        "salt_size": 32,
    },
    {
        "algo": "ChaCha20-Poly1305",
        "cipher": "ChaChaPoly",
        "key_size": 32,
        "salt_size": 32,
    }
]

def removeDash(input):
    return input.replace('-', '')
}%

final class RequestEncoderTests: XCTestCase {
    %for cipher in ciphers:

    func testEncodeShadowsocksRequestWith${removeDash(cipher['algo'])}() throws {
        let passwordReference = "BeMWIH2K5YtZ"
        let destinationAddress = NetAddress.socketAddress(
            try! .init(ipAddress: "192.168.1.1", port: 80)
        )
        let handler = MessageToByteHandler(
            RequestEncoder.init(
                algorithm: .init(rawValue: "${cipher['algo']}")!,
                passwordReference: passwordReference,
                destinationAddress: destinationAddress
            )
        )
        let channel = EmbeddedChannel(handler: handler)

        var nonce = [UInt8](repeating: 0, count: 12)

        let packets: [[UInt8]] = [
            [1, 2],
            [3, 4],
            [5],
        ]

        var symmetricKey: SymmetricKey!

        for (i, bytesToWrite) in packets.enumerated() {
            try channel.writeOutbound(ByteBuffer(bytes: bytesToWrite))
            var byteBuffer = try channel.readOutbound(as: ByteBuffer.self)!

            var combined: [UInt8]!
            var actualData: Data!
            var ciphertext: Data!
            var encryptedDataLength: Int = 0

            // Only first packet contains address info.
            if i == 0 {
                // Read salt value.
                let salt = byteBuffer.readBytes(length: ${cipher['salt_size']})!

                symmetricKey = hkdfDerivedSymmetricKey(
                    secretKey: passwordReference,
                    salt: salt,
                    outputByteCount: ${cipher['key_size']}
                )

                // Read encrypted address buffer.
                combined = nonce + byteBuffer.readBytes(length: 18)!
                ciphertext = try ${cipher['cipher']}.open(.init(combined: combined), using: symmetricKey)
                encryptedDataLength = ciphertext.withUnsafeBytes {
                    Int($0.bindMemory(to: UInt16.self).baseAddress!.pointee.bigEndian) + 16
                }
                nonce.increment(nonce.count)

                combined = nonce + byteBuffer.readBytes(length: encryptedDataLength)!
                var actualData = try ${cipher['cipher']}.open(.init(combined: combined), using: symmetricKey)
                nonce.increment(nonce.count)
                XCTAssertEqual(try actualData.readAddress(), destinationAddress)
            }

            // Read encrypted request data.
            combined = nonce + byteBuffer.readBytes(length: 18)!
            ciphertext = try ${cipher['cipher']}.open(.init(combined: combined), using: symmetricKey)
            encryptedDataLength = ciphertext.withUnsafeBytes {
                Int($0.bindMemory(to: UInt16.self).baseAddress!.pointee.bigEndian) + 16
            }
            nonce.increment(nonce.count)

            combined = nonce + byteBuffer.readBytes(length: encryptedDataLength)!
            actualData = try ${cipher['cipher']}.open(.init(combined: combined), using: symmetricKey)
            nonce.increment(nonce.count)
            XCTAssertEqual(actualData, Data(bytesToWrite))
            XCTAssertEqual(byteBuffer.readableBytes, 0)
        }
    }
    %end
}
